---
description: 
globs: 
alwaysApply: false
---
## Rule: Safe Defaults & Fail-Fast Guards

> **Purpose**
>
> 1. Prevent `undefined`/`null` errors by supplying defaults.
> 2. Exit early from any conditional when prerequisites aren’t met, keeping main logic flat.
> 3. **Encourage defaults in signatures**: catches missing data even before you enter the function.

### 1. Nullish Coalescing + Optional Chaining

- **Guard deep property access**: always use `?.` before you touch a potentially missing object.
- **Supply a default with `??`**: whenever a value could be `null`/`undefined`, fall back immediately.
- **Declare defaults in signatures**: for function params that might be omitted.

```ts
// ✔️ Safe property access + default
const username = response.user?.name ?? "guest";

// ✔️ Default param
function send(message: string, options: SendOptions = {}) {
  const retries = options.retries ?? 3;
  // …
}
```

### 2. Early Return / Guard Clauses

- At the top of **any** block—functions, loops, `if`/`else`, `switch` cases—check your preconditions and return (or throw) immediately on failure.
- This “fail-fast” style:
  1. Avoids deeply nested logic
  2. Makes it impossible to run downstream code on bad inputs
  3. Signals exactly where you handled the invalid state

```ts
function processOrder(order?: Order) {
  @nullish-coalescing.mdc
  if (!order) {
    console.error('No order provided');
    return;                  // ← early return
  }

  // Now safe to use order.id, order.items, etc.
  const count = order.items?.length ?? 0;
  // …
}

// In loops:
for (let i = 0, len = items?.length ?? 0; i < len; i++) {
  if (!items[i].price) {
    @nullish-coalescing.mdc
    continue;                // skip malformed entry
  }
  // …
}

// In switch:
switch (status) {
  case 'ready':
    // …
    break;
  default:
    @nullish-coalescing.mdc
    return handleUnknown(status);
}
```
